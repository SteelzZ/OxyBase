=Oxy_Domain=
Oxy_Domain package provides a lightweight and flexible framework to create domain by applying Domain Driven Design (DDD) principles.
DDD states that your domain model should not be tied up to any framework, but we know that it's not always possible or perhaps I should say that it's not that bad if you can reuse something that would speed up your development process.

Oxy_Domain contains the following sub packages:
 * AggregateRoot
 * Entity
 * Repository
 * ValueObject


==AggregateRoot==
In DDD world Aggregate Root is an entity that has an unique identity and is responsible for other entities, called child entities. 
Child entities can not be accessed directly from outside, everything is controlled by AR. You are allowed to pass child entity to other AR but it should not not rely on given reference.
Other important notice is that once you store your AR you store child entities along with it.
All this leads to a general AR interface like this:
{{{
/**
 * @category Oxy
 * @package Oxy_Domain
 * @subpackage Entity
 * @author Tomas Bartkus <to.bartkus@gmail.com>
 */
interface Oxy_Domain_AggregateRoot_AggregateRootInterface
    extends Oxy_Domain_EntityInterface
{  
    /**
     * @return Oxy_Domain_AggregateRoot_ChildEntitiesCollection
     */
    public function getChildEntities();
}
}}}

Yes, return child entities.

==Entity==
Entity in DDD is "something" that has unique identifier. It's more complicated than this of course but you should read more about it if you want to get better understanding.

Now AR is also entity at the same time, because it has unique identifier and the main difference between AR and Entity is that AR has child entities to care about and Entity does not. 
So let's define our entities interface:
{{{
/**
 * Entity interface
 *
 * @category Oxy
 * @package Oxy_Domain
 * @author Tomas Bartkus <to.bartkus@gmail.com>
 */
interface Oxy_Domain_EntityInterface
{
   /**
     * Returns unique identifier
     * 
     * @return Oxy_Guid
     */
    public function getGuid();
}
}}}
Entity interface defines single method that returns identity and that is main characteristic of entity.

If we would talk about child entities difference between entity would be that child entity has unique identifier but that identifier is unique only under AR. Entity on the other hand has a global unique identifier, like email address.
So our child entity extends normal entity interface by adding one more method to return AR that it belongs to. 
{{{
/**
 * @category Oxy
 * @package Oxy_Domain
 * @subpackage Entity
 * @author Tomas Bartkus <to.bartkus@gmail.com>
 */
interface Oxy_Domain_AggregateRoot_ChildEntityInterface
    extends Oxy_Domain_EntityInterface
{
    /**
     * @return Oxy_Domain_AggregateRoot_AggregateRootInterface
     */
    public function getAggregateRoot();
}
}}}

This package also has a strongly typed collection that accepts only *Oxy_Domain_AggregateRoot_ChildEntityInterface* this type of instances. It is useful small thing that will help you to manage child entities in AR (we will see later how).
{{{
/**
 * Entities collection
 *
 * @category Oxy
 * @package Oxy_Domain
 * @subpackage Entity
 * @author Tomas Bartkus <to.bartkus@gmail.com>
 **/
class Oxy_Domain_AggregateRoot_ChildEntitiesCollection extends Oxy_Collection
{
	/**
	 * @param array $collectionItems
	 */
	public function __construct(array $collectionItems = array())
	{
		parent::__construct(
                    'Oxy_Domain_AggregateRoot_ChildEntityInterface', 
		    $collectionItems
		);		
	}    
	
    /**
     * @param Oxy_Collection $collection $collection
     * @throws InvalidArgumentException when wrong type
     */
    public function addCollection(Oxy_Collection $collection)
    {
        foreach($collection as $value){
            $this->set(
                (string)$value->getGuid(), 
                $value
            );
        }
    }
}
}}}


So that basically it. These interfaces is all you need to start working in DDD way. But it's nothing basically, right? 

So let's move to more interesting stuff - "Event Sourcing".

Because at the moment I am focusing on this type of AR this is way it's the only one implementation.

==Event Sourced AR==
So, if you want to create AR that would implement "Event Sourcing" pattern, your AR should extend the following class:
{{{
/**
 * Event sourced Aggregate Root 
 * Base class
 *
 * @category Oxy
 * @package Oxy_Domain
 * @subpackage AggregateRoot
 * @author Tomas Bartkus <to.bartkus@gmail.com>
 */
abstract class Oxy_Domain_AggregateRoot_EventSourcedAbstract 
    extends Oxy_Domain_Entity_EventSourcedAbstract
    implements Oxy_Domain_AggregateRoot_AggregateRootInterface
{    
    /**
     * @var Oxy_Domain_AggregateRoot_ChildEntitiesCollection
     */
    protected $_childEntities;
        
    /**
     * @return Oxy_Domain_AggregateRoot_ChildEntitiesCollection
     */
    public function getChildEntities()
    {
        return $this->_childEntities;
    }
        
    /**
     * Initialize aggregate root
     * 
     * @param Oxy_Guid $guid
     * @param string $realIdentifier
     */
    public function __construct(
    	Oxy_Guid $guid,
    	$realIdentifier
    )
    {
    	parent::__construct($guid, $realIdentifier);
        $this->_childEntities = new Oxy_Domain_AggregateRoot_ChildEntitiesCollection();
    }

    /**
     * Register child entity event
     *
     * @param Oxy_Domain_AggregateRoot_ChildEntityInterface $childEntity
     * @param Oxy_EventStore_Event_EventInterface $event
     *
     * @return void
     */
    public function registerChildEntityEvent(
        Oxy_Domain_AggregateRoot_ChildEntityInterface $childEntity,
        Oxy_EventStore_Event_EventInterface $event
    )
    {
        $this->_childEntities->set((string)$childEntity->getGuid(), $childEntity);
        $this->_appliedEvents->addEvent(
            new Oxy_EventStore_Event_StorableEvent(
                $childEntity->getGuid(),
                $event
            )
        );
    }

    /**
     * @param Oxy_EventStore_Event_EventInterface $event
     *
     * @return void
     */
    protected function _handleEvent(Oxy_EventStore_Event_EventInterface $event)
    {
        // This should not be called when loading from history
        // because if event was applied and we are loading from history
        // just load it do not add it to applied events collection
        // Add event to to applied collection
        // those will be persisted
        $this->_appliedEvents->addEvent(
            new Oxy_EventStore_Event_StorableEvent(
                $this->_guid,
                $event
            )
        );
                
        // Apply event - change state
        $this->_apply($event);
    }
    
    /**
     * Load events
     *
     * @param Oxy_EventStore_Event_StorableEventsCollectionInterface $domainEvents
     */
    public function loadEvents(Oxy_EventStore_Event_StorableEventsCollectionInterface $domainEvents)
    {
        foreach ($domainEvents as $index => $storableEvent) {
            $eventGuid = (string)$storableEvent->getProviderGuid();
            if ($eventGuid === (string)$this->_guid) {
                $this->_apply($storableEvent->getEvent());
            } else if ($this->_childEntities->exists($eventGuid)) {
                $childEntity = $this->_childEntities->get($eventGuid);
                if($childEntity instanceof Oxy_EventStore_EventProvider_EventProviderInterface){
                    $childEntity->loadEvents(
                        new Oxy_EventStore_Event_StorableEventsCollection(
                            array(
                                $storableEvent->getProviderGuid() => $storableEvent->getEvent()
                            )
                        )
                    );
                } else {
                    throw new Oxy_Domain_Exception(
                        sprintf(
                        	'Child entity must implement %s interface', 
                            'Oxy_EventStore_EventProvider_EventProviderInterface'
                        )
                    );
                }
            } else {
                throw new Oxy_Domain_Exception(
                    sprintf('Child entity with guid %s does not exists', $storableEvent->getProviderGuid())
                );
            }
        }
    }
}
}}}
This class handles all magic that is required to enable event sourcing. If we would go in details about the magic, it's pretty simple. 
In your AR you will have behaviors, these behaviors will be implementing all your business rules. Once those rules will be applied your behavior will come to the point that you will have to trigger appropriate event. That event will be expressed in past tense and will state a fact that something has just happened. 
So when you will come to this point you will use base class method - *_handleEvent()* like this:
{{{
$this->_handleEvent(
    new Account_Domain_Account_AggregateRoot_Account_Event_NewAccountCreated(
                            array(
                                'accountGuid' => (string)$this->_guid,
                                'primaryEmail' => (string)$primaryEmailAddress,
                                'password' => (string)$password,
                                'passwordAgain' => (string)$passwordAgain,
                                'isAutoGenerated' => (boolean)$password->isAutoGenerated(),
                                'encodedPassword' => $encodedPassword,
                                'personalInformation' => $ownerPersonalInformation->toArray(),
                                'deliveryInformation' => $ownerDeliveryInformation->toArray(),
                                'settings' => $settings->getProperties(),
                                'state' => Account_Domain_Account_ValueObject_State::ACCOUNT_STATE_INITIALIZED,
                                'emailActivationKey' => (string)$emailActivationKey,
                            	'date' => date('Y-m-d H:i:s'),
                            	'loginState' => (string)$this->_loginState,
                            	'generatedPassword' => $generatedPassword,
        )
    )
);
}}}

This method will register event in AR's applied events collection.
So if you will be triggering more than one event, those will be stored safely.
When you will come to the point that your AR has finished processing command (aka executing behavior) you will pass your AR to repository which will handle persistence of AR. In this case it will persist events somewhere, I say somewhere because it depends on you where you will decide to save them - MongoDB, MySQL, MSSQL etc.  
Let's take our "Account" BC example, and see how it looks in real world. This fragment shows just events creation and registration phase, saving will be explained later.
{{{
class Account_Domain_Account_AggregateRoot_Account 
    extends Oxy_Domain_AggregateRoot_EventSourcedAbstract
{        
  
    /**
     * Setup new account
     * 
     * @param Account_Domain_Account_ValueObject_EmailAddress $primaryEmailAddress
     * @param Account_Domain_Account_ValueObject_Password $password
     * @param Account_Domain_Account_ValueObject_Password $passwordAgain
     * @param Account_Domain_Account_ValueObject_PersonalInformation $ownerPersonalInformation
     * @param Account_Domain_Account_ValueObject_DeliveryInformation $ownerDeliveryInformation
     * @param Account_Domain_Account_ValueObject_Properties $settings
     */
    public function setup(
        Account_Domain_Account_ValueObject_EmailAddress $primaryEmailAddress,
        Account_Domain_Account_ValueObject_Password $password,
        Account_Domain_Account_ValueObject_Password $passwordAgain,
        Account_Domain_Account_ValueObject_PersonalInformation $ownerPersonalInformation,
        Account_Domain_Account_ValueObject_DeliveryInformation $ownerDeliveryInformation,
        Account_Domain_Account_ValueObject_Properties $settings 
    )
    {
        if($this->_isNew()){
            if($this->_comparePasswords($password, $passwordAgain)){
                if($this->_checkPasswordStrength($password)){
                    $emailActivationKey = new Oxy_Guid();
                    $encodedPassword = (string)$password->getEncoded();
                    
                    $generatedPassword = $password->isAutoGenerated() == true ? (string)$password : '';
                    $this->_handleEvent(
                        new Account_Domain_Account_AggregateRoot_Account_Event_NewAccountCreated(
                            array(
                                'accountGuid' => (string)$this->_guid,
                                'primaryEmail' => (string)$primaryEmailAddress,
                                'password' => (string)$password,
                                'passwordAgain' => (string)$passwordAgain,
                                'isAutoGenerated' => (boolean)$password->isAutoGenerated(),
                                'encodedPassword' => $encodedPassword,
                                'personalInformation' => $ownerPersonalInformation->toArray(),
                                'deliveryInformation' => $ownerDeliveryInformation->toArray(),
                                'settings' => $settings->getProperties(),
                                'state' => Account_Domain_Account_ValueObject_State::ACCOUNT_STATE_INITIALIZED,
                                'emailActivationKey' => (string)$emailActivationKey,
                            	'date' => date('Y-m-d H:i:s'),
                            	'loginState' => (string)$this->_loginState,
                            	'generatedPassword' => $generatedPassword,
                            )
                        )
                    );
                } else {                
                    $this->_handleEvent(
                        new Account_Domain_Account_AggregateRoot_Account_Event_PasswordTooWeakExceptionThrown(
                            array(
                                'accountGuid' => (string)$this->_guid,
                                'message' => 'account.error.weak.password',
                                'date' => date('Y-m-d H:i:s'),
                                'additional' => sprintf(
                                    'Password [%s] way to weak',
                                    (string)$password
                                )
                            )
                        )
                    );
                }
            } else {                
                $this->_handleEvent(
                    new Account_Domain_Account_AggregateRoot_Account_Event_PasswordsDidNotMatchExceptionThrown(
                        array(
                            'accountGuid' => (string)$this->_guid,
                            'message' => 'account.error.passwords.didnt.match',
                            'date' => date('Y-m-d H:i:s'),
                            'additional' => sprintf(
                            	'[%s:%s] not equals [%s:%s]', 
                                (string)$password, 
                                (string)$password->getEncoded(), 
                                (string)$passwordAgain, 
                                (string)$passwordAgain->getEncoded()
                            )
                        )
                    )
                );
            }
        } else if($this->_isDeactivated()){
            $this->resurect(
                $primaryEmailAddress, 
                $password, 
                $passwordAgain, 
                $ownerPersonalInformation, 
                $ownerDeliveryInformation, 
                $settings
            );
        }else {
            $this->_handleEvent(
                new Account_Domain_Account_AggregateRoot_Account_Event_AccountAlreadyExistsExceptionThrown(
                    array(
                        'accountGuid' => (string)$this->_guid,
                        'message' => 'account.error.account.already.exists',
                        'date' => date('Y-m-d H:i:s'),
                        'additional' => sprintf(
                            'This email [%s] was trying to setup more than once',
                            (string)$primaryEmailAddress
                        )
                    )
                )
            );
        }
    }
        
    /**
     * @param Account_Domain_Account_AggregateRoot_Account_Event_NewAccountCreated $event
     */
    protected function onNewAccountCreated(
        Account_Domain_Account_AggregateRoot_Account_Event_NewAccountCreated $event
    )
    {
        $this->_primaryEmail = new Account_Domain_Account_ValueObject_EmailAddress(
            $event->getPrimaryEmail()
        );
        
        $this->_state = new Account_Domain_Account_ValueObject_State(
            $event->getState()
        );    
        $this->_currentPassword = new Account_Domain_Account_ValueObject_Password(
            $event->getEncodedPassword(),
            true,
            $event->getIsAutoGenerated()
        );     
        
        $this->_activationKey = new Oxy_Guid($event->getEmailActivationKey());
        $this->_settings = new Account_Domain_Account_ValueObject_Properties($event->getSettings());
    }
    
    /**
     * @param Account_Domain_Account_AggregateRoot_Account_Event_AccountAlreadyExistsExceptionThrown $event
     */
    protected function onAccountAlreadyExistsExceptionThrown(
        Account_Domain_Account_AggregateRoot_Account_Event_AccountAlreadyExistsExceptionThrown $event
    )
    {
    }
    
    /**
     * @param Account_Domain_Account_AggregateRoot_Account_Event_PasswordsDidNotMatchExceptionThrown $event
     */
    protected function onPasswordsDidNotMatchExceptionThrown(
        Account_Domain_Account_AggregateRoot_Account_Event_PasswordsDidNotMatchExceptionThrown $event
    )
    {       
    }
    
    /**
     * @param Account_Domain_Account_AggregateRoot_Account_Event_PasswordTooWeakExceptionThrown $event
     */
    protected function onPasswordTooWeakExceptionThrown(
        Account_Domain_Account_AggregateRoot_Account_Event_PasswordTooWeakExceptionThrown $event
    )
    {       
    }
}
}}}
As you see, once you have processed data, performed state checks and you are ready to trigger one or other event, all you have to do is just call "_handleEvent" method which will register event in base class. 

With child entities is the same, base class handles everything (we will see later). 

One thing in addition to event registering is that you have to define an internal handler for each of your event. These handlers will be methods which actually will change the state of Entity/AR. You are not allowed to change state in behavior, it's forbidden. Because when you will be retrieving AR from repository those events will be applied to your AR. So it means that only the code in handler will be executed. All this means two very important things, very important:
 * *NEVER CHANGE STATE IN BEHAVIOR*
 * *IN INTERNAL HANDLER CAN NOT BE ANY LOGIC*

First one is pretty clear I guess. Second one might be tricky in the beginning, but as a rule of thumb, you can think like this - *if there is anything else then just direct property state change statement - it's wrong*. It has to be pure state changes statements, like:
{{{
/**
     * @param Account_Domain_Account_AggregateRoot_Account_Event_NewAccountCreated $event
     */
    protected function onNewAccountCreated(
        Account_Domain_Account_AggregateRoot_Account_Event_NewAccountCreated $event
    )
    {
        $this->_primaryEmail = new Account_Domain_Account_ValueObject_EmailAddress(
            $event->getPrimaryEmail()
        );
        
        $this->_state = new Account_Domain_Account_ValueObject_State(
            $event->getState()
        );    
        $this->_currentPassword = new Account_Domain_Account_ValueObject_Password(
            $event->getEncodedPassword(),
            true,
            $event->getIsAutoGenerated()
        );     
        
        $this->_activationKey = new Oxy_Guid($event->getEmailActivationKey());
        $this->_settings = new Account_Domain_Account_ValueObject_Properties($event->getSettings());
    }
}}}
There is no "if something" there is no "new date('Ymdhis')" statements everything is taken from event instance and then applied to entity properties.

And this is how all you business logic is implemented. Now if you are not sure if isn't it to complex as for simple method like "login", well it depends what you are looking for. If you are having *data centric* application then perhaps i would say, no you shouldn't be using it, but if you have more like *behavior driven application* then keep reading and you will understand all benefits by yourself.

Now if we would continue by talking about child entities, there is nothing special about them. Child entities are same entities as ARs and all those rules applies to it. The only thing worth mentioning is that AR base class is handling registered child entity events and is responsible to "know" which event to which entity belongs. But all this is handled by base classes so you don't need to worry about it.
All child entities has to extend this base class:
{{{
/**
 * Event sourced child entity
 * Base class
 *
 * @category Oxy
 * @package Oxy_Domain
 * @subpackage Entity
 * @author Tomas Bartkus <to.bartkus@gmail.com>
 */
abstract class Oxy_Domain_AggregateRoot_EventSourcedChildEntityAbstract
    extends Oxy_Domain_Entity_EventSourcedAbstract
    implements Oxy_Domain_AggregateRoot_ChildEntityInterface
{    
    /**
     * @var Oxy_Domain_AggregateRoot_AggregateRootInterface
     */
    protected $_aggregateRoot;
    
    /**
     * @return Oxy_Guid
     */
    public function getGuid()
    {
        return $this->_guid;
    }

    /**
     * @return Oxy_Domain_AggregateRoot_AggregateRootInterface
     */
    public function getAggregateRoot()
    {
        return $this->_aggregateRoot;
    }

    /**
     * @param Oxy_Guid $guid
     * @param string $guid
     * @param Oxy_Domain_AggregateRoot_AggregateRootInterface $aggregateRoot
     */
    public function __construct(
        Oxy_Guid $guid,
        $realIdentifier,
        Oxy_Domain_AggregateRoot_AggregateRootInterface $aggregateRoot = null
    ) 
    {
        parent::__construct($guid, $realIdentifier);
        $this->_aggregateRoot = $aggregateRoot;
    }
 
	/**
     * @param Oxy_Domain_EventInterface $event
     * @return void
     */
    protected function _handleEvent(Oxy_EventStore_Event_EventInterface $event)
    {
        // This should not be called when loading from history
        // because if event was applied and we are loading from history
        // just load it do not add it to applied events collection
        // Add event to to applied collection
        // those will be persisted
        $this->_aggregateRoot->registerChildEntityEvent($this, $event);
        // Apply event - change state
        $this->_apply($event);
    }
    
    /**
     * @return string
     */
    public function __toString()
    {
        return (string)$this->_guid;
    }
}
}}}
As you see child entity class is the same entity just it has reference to AR and overrides *_handleEvent* method.  

One last thing about AR and child entity is that both extends the following class - *Oxy_EventStore_EventProvider_EventProviderInterface*. This interface is required by Oxy_EventStore, which will be used to store our entities (we will talk more about it in Oxy_EventStore chapter).
{{{
/**
 * Event sourced entity
 * Base class
 *
 * @category Oxy
 * @package Oxy_Domain
 * @subpackage Entity
 * @author Tomas Bartkus <to.bartkus@gmail.com>
 */
abstract class Oxy_Domain_Entity_EventSourcedAbstract
    implements Oxy_Domain_EntityInterface,
               Oxy_EventStore_EventProvider_EventProviderInterface
                
{
    /**
     * @var Oxy_Guid
     */
    protected $_guid;

    /**
     * @var integer
     */
    protected $_version;
    
    /**
     * @var Oxy_EventStore_Event_StorableEventsCollection
     */
    protected $_appliedEvents;
    
    /**
     * @var string
     */
    protected $_realIdentifier;
    
	/**
     * @return Oxy_EventStore_Event_StorableEventsCollection
     */
    public function getChanges()
    {
        return $this->_appliedEvents;
    }
    
	/**
     * @return integer $version
     */
    public function getVersion()
    {
        return $this->_version;
    }
    
    /**
     * @return Oxy_Guid
     */
    public function getGuid()
    {
        return $this->_guid;
    }
    
	/**
     * @param Oxy_Guid $guid
     * @param string $realIdentifier
     */
    public function __construct(
        Oxy_Guid $guid,
        $realIdentifier
    ) 
    {
        $this->_appliedEvents = new Oxy_EventStore_Event_StorableEventsCollection();
        $this->_guid = $guid;
        $this->_realIdentifier = $realIdentifier;
    }
    
    /**
     * @see Oxy_EventStore_EventProvider_EventProviderInterface::getRealIdentifier()
     */
    public function getRealIdentifier()
    {
        return $this->_realIdentifier; 
    }
    
    /**
     * @see Oxy_EventStore_EventProvider_EventProviderInterface::getName()
     */
    public function getName()
    {
        return (string)get_class($this);        
    }
    
    /**
     * @param integer $version
     */
    public function updateVersion($version)
    {
        $this->_version = $version;
    }
    
    /**
     * @param Oxy_EventStore_Event_StorableEventsCollectionInterface $domainEvents
     */
    public function loadEvents(Oxy_EventStore_Event_StorableEventsCollectionInterface $domainEvents)
    {
        foreach ($domainEvents as $index => $storableEvent) {
            if ((string)$storableEvent->getProviderGuid() === (string)$this->_guid) {
                $this->_apply($storableEvent->getEvent());
            } else {
                throw new Oxy_Domain_Exception(
                    sprintf(
                    	'Given event does not belong to this entity - %s [%s]', 
                        (string)$storableEvent->getProviderGuid(),
                        (string)$this->_guid
                    )
                );
            }
        }
    }
    
    /**
     * @param Oxy_EventStore_Event_EventInterface $event
     * @return void
     */
    protected function _handleEvent(Oxy_EventStore_Event_EventInterface $event)
    {
        // This should not be called when loading from history
        // because if event was applied and we are loading from history
        // just load it do not add it to applied events collection
        // Add event to to applied collection
        // those will be persisted
        $this->_appliedEvents->addEvent(
            new Oxy_EventStore_Event_StorableEvent(
                $this->_guid,
                $event
            )
        );
        
        // Apply event - change state
        $this->_apply($event);
    }
    
	/**
     * @param Oxy_Domain_EventInterface $event
     * @return void
     */
    protected function _apply(Oxy_EventStore_Event_EventInterface $event)
    {
        $eventHandlerName = 'on' . $event->getEventName();
        if(method_exists($this, $eventHandlerName)){
        	call_user_func_array(array($this, $eventHandlerName), array($event));
        } else {
        	$this->_onEventHandlerNotFound($event);
        }
    }
    
    /**
     * Child classes can override this one and have their own logic
     * when event handler for given event does not exists anymore 
     * 
     * @param Oxy_EventStore_Event_Interface $event
     * @throws Oxy_Domain_Exception
     */
    protected function _onEventHandlerNotFound(Oxy_EventStore_Event_Interface $event)
    {
        throw new Oxy_Domain_Exception(
    		sprintf('Event handler for %s does not exists', $event->getEventName())
        );        
    }
    
    /**
     * @param string $where
     * @throws Oxy_EventStore_Event_WrongStateException
     */
    protected function _throwWrongStateException($where, $state)
    {
        throw new Oxy_EventStore_Event_WrongStateException(
            sprintf('Can not execute [%s] behaviour in current state [%s]! [%s]', $where, (string)$state, (string)$this->_guid)
        );        
    }
    
    /**
     * @return string
     */
    public function __toString()
    {
        return (string)$this->_guid;
    }
}
}}}


=Oxy_Cqrs=

=Oxy_EventStore=