#labels OxyBase
=READ THIS=
This document is still a draft. Info here will be amended!

=Overview=
This article is tend to be a short guide how to get things working. This is live document and I will keep updating it once there will be a need for that.

=Oxy library=
If you have a framework that you already are working with and you just want to start implementing your business logic (your domain) in DDD way then you just need to download Oxy library and add it to your include path. Once you have it just pick what you need, check documentation and start using.
(Sorry reference guide is not there yet)  

=OxyBase=
Another option is to download whole OxyBase framework that has predefined and tested structure, extract from your current application a part that you want to rebuild in CQRS,DDD way and build it by using OxyBase. And then simply connect those two apps (How to do that we will discuss later). 

==Intro==
Ok, let's try to build up some application. And let's do something more complex then just "hello world", what about "Account" mini system ? Most of our applications has "Account" feature, right? So let's create some basic "Account" system that would serve as an example how things work in OxyBase.
I will assume that you have RabbitMQ and MongoDB installed and ready for use. Of course you will be able to use any messaging system or storage engine it's just a matter of creating interface implementations, but at the moment I will stick to this configuration, because it works best for me (Why we will discuss in later posts).

==Setup OxyBase==
Download latest stable release or checkout it from svn. Extract the content in your workspace. You should have structure like that:
 * documentation
 * html
 * project
   * apps
   * build
   * config
   * library
 * public 
 * tests
 * tmp

Let's talk about it a little. 
*Documentation* folder is for your application documents, obviously. You will host your domain here, so you will need a place to store it. I like to have everything that is related to application somewhere close.

*project* folder is where your app(-s) will live. Because from the very beginning I was missing something in ZF that would let me separate my domains, I have created *apps* folder that actually contains more than one application (more than one bounded context). So in *apps* we will store our BCs, in this example it will be "Account" BC.

*build* folder contains tools, scripts required to build an application. Well those build scripts has meaning like "setup-clean-build-for-new-developer", "setup-build-with-some-snapshot", "rebuild-di-container", "clean-up-databases", "run-unit-tests", "rebuild-app-config" and so on. I have a rule like if you do some task for a second time, think about putting it as phing target. Yes, as build tool we use "Phing" and OxyBase has some build scripts that I am using currently for development, staging and production environments.

*config* folder contains project configuration file. By default it has default.xml file which is being used as template to create real config.xml file. In *build/config* folder we store project properties file with connection data to databases, messaging systems etc. Each environment (dev, staging, production) has its own so once we do build
config.xml file we take default.xml and we fill in data from properties file. 

*library* folder is used to store all your libraries. In my projects I add library as external repository and I work with it like with separate project.

*public* folder is our document root. If for example we will build some UI for our domain then our entry point will be here, as well as all public content (images, css etc.)

*tests* yes here we will store unit tests. 

*tmp* I am setting up *tmp* folder per project. The reason for that is that if I clean up sessions, ill do it only for one BC.

Once you got it make a copy of "project/build/build.properties" file like "my.build.properties" and let's amend it a bit. At the moment file has the following properties: 
{{{
[System]
*app.path=C:/Development/Workspace/OxyBase/* - path to our app
*tmp.dir=C:/Development/Workspace/OxyBase/tmp/* - path to tmp dir
*api.url=r100.msa.local.oxybase.com* - URL to our BC API
*protocol=http* - HTTPS or HTTP
*environment=development* - environment

[Application]
*application.domains=Account* - what BCs we are hosting within this instance

[Mongo connection]
*mongo.connection.string=mongodb://localhost:27017*
*mongo.replica.set=false*

[Database names]
*account.eventstore.dbname = r100_account_events*
*account.reporting.dbname = r100_account*

[Messaging options]
*messaging.consumer.become.listener = true* - should our consumer become a listener after he finished consuming messages or not? Because sometimes you want just to spawn some consumers to help your current ones and once queue is empty just kill them
*messaging.consumer.name.prefix = consumer-steelzz-* - consumer prefix
*messaging.broker.host = tcp://guest:guest@192.168.1.245:5672/?txt-mode=true* - connection string to messaging system, *txt-mode=true* defines that it is transactional queue
*messaging.borker.command.handler.service.prefix = oxyCqrsCommandHandlerBuilder* - this is service prefix that is used by daemon to get from container command handlers builder (we will discuss it in more details later)
*messaging.broker.account.connection = tcp://guest:guest@192.168.1.245:5672/?txt-mode=true|queue-id=queue.account* - connection string to messaging system to concrete queue
*messaging.borker.account.autocommit* - auto-commit messages or leave it to client
}}}

Next bit is only for windows users :) :
Now let's prepare ourselves for development (I'll make build task later for this). Copy files from *app.path/project/build/exec* folder somewhere on desktop to "Account project" and open each of it with text editor. Replace variables with correct ones to your environment:
 * ${app.path} - path to the system (copy-paste from your properties file)
 * ${context} - for this example it should be "Account"
 * ${properties.file.name} - your properties file name "my.build.properties" for example
 * ${queue.id} - replace with "queue.account"
Once that is done double click on "dev-do-build.bat" and when asked enter "prepare".
Then double click on "dev-do-rebuild-di.bat".
And lastly double click on "dev-do-run-consumer.bat", this will launch consumer. If you see something like text below then you are ready to go
{{{
Connected to broker @ host tcp://guest:guest@192.168.1.245:5672/?txt-mode=true|queue-id=queue.account in 0.023804903030396 seconds
Configured consumer with consumer-node-1 name in 0.0074441432952881 seconds

 Niam niam :)
}}}

If you are not on windows: 
Open console and navigate to your *app.path/project/build* folder and execute the following command:
{{{
phing -f dev-build.xml -DpropertyFile=config/my.build.properties prepare
}}}
This will prepare project. Will create config.xml file for example.
Then execute:
{{{
phing -f dev-build.xml -DpropertyFile=config/my.build.properties rebuild-di
}}}
This will rebuild DI container.

Then navigate to *app.path/project/apps/Account/daemon* folder and execute the following command:
{{{
./consumer-daemon.php *app.path/project/build/config/my.build.properties* 1 my-consumer queue.account Account
}}}

This should start a daemon. With the following command you should be able to see if it is running:
{{{
ps uf -C consumer-daemon.php
}}}
==Let's test it==
Now set-up a virtual host and set a document root to *app.path/public*.
Open your browser and navigate to *protocol*+*api.url*/api/account/account/general/v1r0/wsdl . You should see your account web service WSDL.

Now open console and navigate to *app.path/tests* and execute command:
{{{
php TestSoapClient.php
}}}
You will be asked to enter WSDL url so copy-paste this one *protocol*+*api.url*/api/account/account/general/v1r0/wsdl and then follow up the instructions.

SOAP client it's just an example how you can use your application, but it can be anything - native php calls for example.